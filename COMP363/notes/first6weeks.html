<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Six weeks of Algorithms &mdash; Leo Irakliotis&#39; courses  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Leo Irakliotis' courses
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Courses</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../COMP264/introduction.html">COMP 264 Computer Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COMP271/introduction.html">COMP 271 Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COMP306/introduction.html">COMP 306+406 Data mining</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">COMP 363+460 Algorithms</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Past courses</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../COMP163/introduction.html">COMP 163 Discrete Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COMP170/introduction.html">COMP 170 Introduction to Java Programming</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Projects</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../DEI/DEI.html">DEI initiative</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DBD/introduction.html">Databases Design</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../LeoIrakliotis.html">Shameless self-promotion</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Leo Irakliotis' courses</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Six weeks of Algorithms</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/COMP363/notes/first6weeks.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="six-weeks-of-algorithms">
<h1>Six weeks of Algorithms<a class="headerlink" href="#six-weeks-of-algorithms" title="Link to this heading"></a></h1>
<p>In the first six weeks of the course we covered the following topics.</p>
<section id="python-and-jupyter-notebooks">
<h2>Python and Jupyter notebooks<a class="headerlink" href="#python-and-jupyter-notebooks" title="Link to this heading"></a></h2>
<p><a class="reference external" href="https://jupyter.org/">Jupyter notebooks</a> are very popular tools among data scientists. They are also extremely useful for our course because they allow us to mix <a class="reference external" href="https://en.wikipedia.org/wiki/Markup_language">marked-up documentation</a> and code together. The programming environment these notebooks offer is not as sophisticated as that of an IDE, but it provides basic functionality such as autocompletion. Of course we can always download and use a fuller integrated development environment such as <a class="reference external" href="https://www.jetbrains.com/pycharm/download/download-thanks.html?platform=mac&amp;code=PCC">PyCharm</a> (the sibling application to IntelliJ); <a class="reference external" href="https://www.spyder-ide.org/">Spyder</a>, etc; not to mention the awesomness of <em>vim</em> and <em>emacs</em>.</p>
</section>
<section id="trade-off-between-code-reusability-and-performance">
<h2>Trade off between code reusability and performance<a class="headerlink" href="#trade-off-between-code-reusability-and-performance" title="Link to this heading"></a></h2>
<p>Reusable code is elegant but not always efficient. We explored this trade off with the <a class="reference external" href="https://colab.research.google.com/drive/1lq4lFjDIletiCRudys1fgJS3oHlUu7Cs?usp=sharing">Intersecting Linked Lists</a> notebook. We saw how to write nodes and linked lists in Python, and developed techniques for telling if two lists intersect or not. One technique reused existing code but its performance was poor because it had to check every pair of possible node combinations between the two lists. The other technique duplicated existing code but performed must faster because it ended after detecting the first intersection between the linked lists.</p>
<p>The search for intersections was based on comparison between the string contents of nodes. The code used fixed length strings that were randomly generated. The likelihood that two noe3w intersect is directly proportional to the length of these strings. There are <span class="math notranslate nohighlight">\(26\)</span> different node contents for strings with length 1, <span class="math notranslate nohighlight">\(26^2\)</span> different node contents for strings with length 2, and so on. Lists with 2-letter contents and more than <span class="math notranslate nohighlight">\(26^2\)</span> nodes, are certain to have an intersection. Let’s consider two lists with <span class="math notranslate nohighlight">\(10^3\)</span> elements each. It takes <span class="math notranslate nohighlight">\(10^6\)</span> steps for the elegant method and approximately <span class="math notranslate nohighlight">\(26^2\)</span> steps for the efficient method to detect an intersection.</p>
<p>The analysis of the trade offs above led to the discussion about asymptotic behavior: what are the time demands of each method, for sufficiently large lists. If <span class="math notranslate nohighlight">\(n\)</span> is the number of nodes in each of the two lists we are checking, can the number of steps each method takes be described in terms of <span class="math notranslate nohighlight">\(n\)</span>? We call this behavior asymptotic and use the big-oh (<span class="math notranslate nohighlight">\(\mathcal{O}\)</span>) notation to express it. (We also use <span class="math notranslate nohighlight">\(\Theta\)</span> and <span class="math notranslate nohighlight">\(\Omega\)</span> expressions for asymptotic notation, but <span class="math notranslate nohighlight">\(\mathcal{O}\)</span> rules them all). In terms of big-oh, the elegant method is <span class="math notranslate nohighlight">\(\mathcal{O}(n^2)\)</span> and the efficient method is <span class="math notranslate nohighlight">\(\mathcal{O}(26^L)\)</span> where <span class="math notranslate nohighlight">\(L\)</span> is the number of letters in the string content of the node. For sufficiently large values of <span class="math notranslate nohighlight">\(n\)</span>, the efficient method runs in constant time and therefore more preferable than the elegant method.</p>
</section>
<section id="recursion">
<h2>Recursion<a class="headerlink" href="#recursion" title="Link to this heading"></a></h2>
<p>We spent a good deal of time on recursion because because it is a foundational topic in computing. It is a strategy for understanding how to solve seemingly complex problems. Even for problems whose ultimate solution is not recursive, the solving strategy evolved from a humble recursive beginning. One such problem is the computation of the Fibonacci sequence. The recursive solution is slow because it repeats computations. We can avoid repetitions by storing the results of intermediate steps.</p>
<section id="divide-and-conquer">
<h3>Divide and Conquer<a class="headerlink" href="#divide-and-conquer" title="Link to this heading"></a></h3>
<p>Divide and Conquer splits a problem into smaller pieces until a trivial solution can be found, then assembles these partial solutions together. Like all recursive tactics, divide and conquer works if the reduction to smaller problem eventually leads to a trivial (base) case that can be solved without further division. <em>Split multiplication</em> is a good example of divide and conquer. It is based on the observation that any number can be written as the sum of two products: <span class="math notranslate nohighlight">\(x=a\cdot 10^2+b\cdot 10^0\)</span>; for example <span class="math notranslate nohighlight">\(4389=43\cdot10^2+89\cdot 10^0\)</span>. For two variables with the same number of digits, <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y=c\cdot 10O^s+d\cdot 10^0\)</span>, their product is</p>
<div class="math notranslate nohighlight">
\[xy = a c10^{2s} + (ad+cb)10^s + bd10^0\]</div>
<p>Products <span class="math notranslate nohighlight">\(ac\)</span>, <span class="math notranslate nohighlight">\(ad\)</span>, <span class="math notranslate nohighlight">\(cb\)</span>, and <span class="math notranslate nohighlight">\(bd\)</span> above can be broken down in similar fashion, splitting the numbers into halves, until each number has a single digit. Such numbers are very easy to multiply. Beginning with these single digit products, we can go back assembling the solution back to the initial product <span class="math notranslate nohighlight">\(xy\)</span>.</p>
<p>A faster way for split-multiply was introduced by Anatoli Karatsuba in the 1960s. As we compared the performance between the plain split multiplication and Karatsuba’s approach, we saw how the interplay between recursive calls, size of subproblems passed to them, and time required for assemblying the partial results to a solution, all affect performance time. The <em>Master Theorem</em> puts together the relations between these three characteristics, to determine the asymptotic behavior of a divide and conquer algorithm.</p>
</section>
<section id="memoization-and-dynamic-programming">
<h3>Memoization and Dynamic Programming<a class="headerlink" href="#memoization-and-dynamic-programming" title="Link to this heading"></a></h3>
<p>Recursion can be slow and often demanding on memory resources. For some problems, we can aleviate the pressure by using look-up tables or by exploiting optimal substructures. The use of look-up tables is called <em>memoization</em>. From an atrocious <span class="math notranslate nohighlight">\(\mathcal{O}(2^n)\)</span> our computation for Fibonacci numbers went to <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span> as we moved from pure recursion to the use of a simple array, holding past results. Not only that, but we also found we don’t even need an array, because there is a plain iterative way to compute Fibonacci numbers using only two storage variables, one for the previous term and one for the prior previous term:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Previous term (i.e., F(n-1))</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Prior previous term (i.e., F(n-2))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1">#  We are here because n &gt;= 2</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>  <span class="c1"># Iterative loop</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">pp</span>  <span class="c1"># Fibonacci term is sum of two past terms</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="n">p</span>  <span class="c1"># Previous becomes prior previous</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">f</span>  <span class="c1"># Value just computed becomes previous</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Next iteration</span>
    <span class="k">return</span> <span class="n">f</span>
</pre></div>
</div>
<p>Dynamic programming takes this technique further and allows some backtracking to provide details about a solution. The typical example is the Knapsack problem. We solved the 0/1 version of the problem: <a class="reference external" href="https://colab.research.google.com/drive/1SRcSScTx9MQA9jGCGfv_7fn8x6CGlSaq">the museum heist scenario</a>. Other variants of the problem include the bounded Knapsack (more akin to a grocery store heist) and the unbounded Knapsack (where there is no limit in the quantity of each item).</p>
<p>Practical applications of the Knapsack problem – other than stealing from a museum, of course – include optimization of investment strategies, resource planning, scheduling, and design of diets among other things.</p>
</section>
</section>
<section id="optimal-stopping">
<h2>Optimal Stopping<a class="headerlink" href="#optimal-stopping" title="Link to this heading"></a></h2>
<p>Optimal stopping is a very practical algorithm that optimizes the outcome of certain selection searches. The algorithm works in cases when we do not know the range of rankings and also when we cannot go back and select something after we passed it. If we plan to search up to <span class="math notranslate nohighlight">\(N\)</span> items, the algorithm suggests that we go through the first <span class="math notranslate nohighlight">\(N/e\)</span> items and get an idea of the rankings based on some metric (e.g., quality, during an apartment hunt). Then go through the remaining <span class="math notranslate nohighlight">\(N(e-1)/e\)</span> items and select the first one that is better than the best of the earlier group. We also saw that the algorithm works well only when the range of ranking is in the same range as <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>For example, if we rank items on a scale of 1-10, the algorithm works well for <span class="math notranslate nohighlight">\(N&lt;20\)</span>. After that, the output fails and soon becomes 0, i.e., no selection can be made. That’s reasonable consider that if <span class="math notranslate nohighlight">\(N=1000\)</span> then <span class="math notranslate nohighlight">\(N/e\approx 368\)</span>. Among 368 items in the sample group, it is almost certain that one of them will be ranked at 10, assuming some uniform distribution. Moving to the second group of 623 items, it will be impossible to find something with a better ranking than 10.</p>
</section>
<section id="asymptotic-formalism">
<h2>Asymptotic Formalism<a class="headerlink" href="#asymptotic-formalism" title="Link to this heading"></a></h2>
<p>In estimating performance of algorithms (and programs that implement them), we often look at the worst case scenario. If we can live with it, we implement the algorithm. For example, the efficient method to find the intersection of two linked lists performs reasonably fast if an intersection exists. If the two lists do not intersect, the efficient method performs as slowly as the elegant method. And if the intersection is at the last node of each list, there is no difference in the performance of the two methods.</p>
<p>The worst case estimate is described with the <em>big-o</em> asymptote. Given two functions   <span class="math notranslate nohighlight">\(f, g: \mathbb{N}_+ \mapsto\mathbb{R}_+\)</span> we say that <span class="math notranslate nohighlight">\(f(n)\)</span> is <span class="math notranslate nohighlight">\(\mathcal{O}(g(n))\)</span> if there is a positive real constant <span class="math notranslate nohighlight">\(c\)</span> such that <span class="math notranslate nohighlight">\(f(n)\leq c g(n)\)</span> for <span class="math notranslate nohighlight">\(n&gt;n_O\)</span>, where <span class="math notranslate nohighlight">\(n_0 \geq 1\)</span>. Sometimes we write <span class="math notranslate nohighlight">\(f(n)\in \mathcal{O}(g(n))\)</span>, to denote the same behavior between <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>.</p>
<p>For example, if <span class="math notranslate nohighlight">\(f(n)=8n+11\)</span> and <span class="math notranslate nohighlight">\(g(n)=n\)</span>, can we show that <span class="math notranslate nohighlight">\(f(n) \in\mathcal{O}(g(n))\)</span>? To do so, we need to find a constant <span class="math notranslate nohighlight">\(c\in\mathbb{R}_+\)</span> such that <span class="math notranslate nohighlight">\(f(n)\leq cg(n)\)</span> for <span class="math notranslate nohighlight">\(n&gt;n_0\)</span>. We also need to find what is the value of <span class="math notranslate nohighlight">\(n_0\)</span>.</p>
<p>Solving for <span class="math notranslate nohighlight">\(c\)</span> we get</p>
<div class="math notranslate nohighlight">
\[\begin{split}c  \geq \frac{f(n)}{g(n)} = &amp; \frac{8n+11}{n} \\
                            = &amp; 8 + \frac{11}{n}\end{split}\]</div>
<p>For any value of <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(8+\frac{11}{n} &gt; 8\)</span> and so any value <span class="math notranslate nohighlight">\(c&gt;8\)</span> will satisfy the condition <span class="math notranslate nohighlight">\(f(c) \leq cg(n)\)</span>. For example, if <span class="math notranslate nohighlight">\(c=9\)</span>, then <span class="math notranslate nohighlight">\(8n+11 \leq 9n\)</span> for <span class="math notranslate nohighlight">\(n&gt;10\)</span>. Therefore, <span class="math notranslate nohighlight">\(8n+11\in\mathcal{O}(n)\)</span>.</p>
<section id="simple-exercises">
<h3>Simple exercises<a class="headerlink" href="#simple-exercises" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>Show that <span class="math notranslate nohighlight">\(\sin^2{(n)}\in\mathcal{O}(1)\)</span>.</p></li>
<li><p>Show that <span class="math notranslate nohighlight">\(n\sin^2{(n)}\in\mathcal{O}(n)\)</span>.</p></li>
<li><p>Show that <span class="math notranslate nohighlight">\(n^x\in\mathcal{O}(n)\)</span> for <span class="math notranslate nohighlight">\(0&lt;x&lt;1\)</span>.</p></li>
<li><p>Show that <span class="math notranslate nohighlight">\((1+2+3+\ldots +(n-1)+n)\in\mathcal{O}(n^2)\)</span>.</p></li>
<li><p>Explain why <span class="math notranslate nohighlight">\(\cos{(n)}\not\in\mathcal{O}(g(n))\)</span> for any <span class="math notranslate nohighlight">\(g(n): \mathbb{N}_+ \mapsto\mathbb{R}_+\)</span>.</p></li>
</ul>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019-2023, Leo Irakliotis.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>